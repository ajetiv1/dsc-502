# -*- coding: utf-8 -*-
"""DSC502-Ajeti-final-project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11BUKgVnut0wTPjS4h9Gc8PkjpLUVtSC4

# Data Maninpulation
"""

import pandas as pd

df_airports = pd.read_csv('/content/drive/MyDrive/dsc502/airports1.csv')

# remove rows with missing values
df_airports.dropna(inplace=True) 

df_airports

import folium
# initialize the map and store it in a m object
map = folium.Map(location=[48, -115], zoom_start=4)

for index, row in df_airports.iterrows():
  loc = [row['LATITUDE'], row['LONGITUDE']]
  c = folium.Circle(radius=20, location=loc, color='red', fill=True)
  c.add_to(map)

# show the map
map

#raw data
df_flights = pd.read_csv('/content/drive/MyDrive/dsc502/flights-abr.csv')
df_flights

#Cleaning raw data, taking columns MONTH and DAY and covert into a date type 
df_date = df_flights.loc[:,'MONTH':'DAY']
df_date['YEAR'] = 2015
df_date['MONTH'] = df_date['MONTH'].apply(lambda x: '{0:0>2}'.format(x))
df_date['DAY'] = df_date['DAY'].apply(lambda x: '{0:0>2}'.format(x))
df_date = df_date.applymap(str)
df_date['DATE_S'] = df_date['DAY']+ df_date['MONTH'] + df_date['YEAR']
df_date['DATE'] = pd.to_datetime(df_date['DATE_S'], format='%d%m%Y')
df_date

#Date part of dataframe that with be merged with other dataframes
df_date2 = df_date.loc[:,'DATE']
df_date2

#convert hours as int to HHMM format
import numpy as np
from datetime import datetime

df_times = df_flights[['SCHEDULED_DEPARTURE', 'DEPARTURE_TIME','SCHEDULED_ARRIVAL', 'ARRIVAL_TIME']]
df_times = df_times.fillna(0)
df_times = df_times.applymap(int)
df_times['SCHEDULED_DEPARTURE'] = df_times['SCHEDULED_DEPARTURE'].apply(lambda x: '{0:0>4}'.format(x))
df_times['DEPARTURE_TIME'] = df_times['DEPARTURE_TIME'].apply(lambda x: '{0:0>4}'.format(x))
df_times['SCHEDULED_ARRIVAL'] = df_times['SCHEDULED_ARRIVAL'].apply(lambda x: '{0:0>4}'.format(x))
df_times['ARRIVAL_TIME'] = df_times['ARRIVAL_TIME'].apply(lambda x: '{0:0>4}'.format(x))
df_times = df_times.applymap(str)
# df_times['time_datetime'] = df_times.apply(lambda x: datetime.strptime(x,'%H%M'))
# df_times

#converting NaN to zeros for delay times
import numpy as np

df_delays = df_flights.loc[:,'AIR_SYSTEM_DELAY':'WEATHER_DELAY']
df_delays = df_delays.fillna(0)
df_delays['TOTAL_DELAY'] = df_delays.sum(axis=1)
df_delays = df_delays.astype('int')
df_delays

df_delays.describe().round(2)

#marging all the parts of the dataframes into one final dataframe with date and
#fixed NaN values

df3 = df_flights.loc[:,'DAY_OF_WEEK':'CANCELLATION_REASON']

df_final = pd.concat([df_date2, df3, df_delays], axis=1, join='inner')
df_final

#df for canceled flights and the canelation reason
df_canceled = df_final.loc[df_final['CANCELLED'] == 1, ['DATE','DAY_OF_WEEK','AIRLINE','ORIGIN_AIRPORT','DESTINATION_AIRPORT','CANCELLATION_REASON']]
df_canceled

#df for diverted flights
df_diverted = df_final.loc[df_final['DIVERTED'] == 1, ['DATE','DAY_OF_WEEK','AIRLINE','ORIGIN_AIRPORT','DESTINATION_AIRPORT']]
df_diverted

#df for delayed flights for any reason
df_delayed = df_final.loc[df_final['TOTAL_DELAY'] > 0]
df_delayed

df_flights['ORIGIN_AIRPORT'].value_counts().loc[lambda x : x>20000]



df_flights['DESTINATION_AIRPORT'].value_counts().loc[lambda x : x>20000]

cancel_count = df_canceled['DATE'].value_counts()
cancel_count

airline_delays = df_delayed['AIRLINE'].value_counts()
airline_delays

import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot()

airlines = ['Southwest Airlines', 'Atlantic Southeast Airlines', 'Delta Air Lines', 'Skywest Airlines', 'American Eagle Airlines', 'American Airlines','United Air Lines','US Airways','JetBlue Airways','Spirit Air Lines','Frontier Airlines','Alaska Airlines','Hawaiian Airlines','Virgin America']
n_delays = [42195, 26118, 24672, 24342, 21311, 21230, 20323, 15026, 13789, 5902, 5428, 4153, 2103, 1936]

ax.bar(airlines, n_delays)
ax.set_xlabel('Airline')
ax.set_ylabel('Number of Delays')

df_a1 = pd.read_csv('/content/drive/MyDrive/dsc502/airlines.csv')
df_a1 = df_a1.assign(ARC=range(len(df_a1)))
df_a2 = pd.DataFrame()
df_a2['IATA_CODE'] = df_delayed['AIRLINE']
df_a3 = df_a2.merge(df_a1, on='IATA_CODE')
df_a4 = pd.DataFrame()
df_a4['IATA_CODE'] = df_flights['AIRLINE']
df_a5 = df_a4.merge(df_a1, on='IATA_CODE')
df_a5



df_p1 = df_airports["IATA_CODE"]
#df_p1.reset_index(inplace=True)
# df_p2 = pd.DataFrame()
# df_p3 = pd.DataFrame()
# df_p2['IATA_CODE'] = df_flights['ORIGIN_AIRPORT']
# df_p3['IATA_CODE'] = df_flights['DESTINATION_AIRPORT']
df_p1

df_canceled['CANCELLATION_REASON'].value_counts()

"""# Modeling

KNN Classification
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import confusion_matrix

df_flights

df_final

df_f1 = df_flights[['MONTH','DAY','DAY_OF_WEEK','SCHEDULED_DEPARTURE','CANCELLED']]

# Features
X = df_f1.loc[:, :'SCHEDULED_DEPARTURE']

# Label : Cancellation
y = df_f1.loc[:, 'CANCELLED']

# Generate the train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=1)

X_train

classifier = KNeighborsClassifier(n_neighbors = 7, p = 2, metric='euclidean')

# "Train" the model
classifier.fit(X_train, y_train)

# Run the model to make predictions based on test set
y_pred = classifier.predict(X_test)

cm = confusion_matrix(y_test, y_pred)
print(cm)

accuracy = classifier.score(X_test, y_test)
print('Test set accuracy:', accuracy)

"""KNN Regression"""

df_f2 = df_flights.loc[df_flights['CANCELLED'] == 0]
df_f3 = df_f2.loc[df_f2['DIVERTED'] == 0] 
df_f3 = df_f3.fillna(0)
df_f4 = df_f3.loc[:,'AIR_SYSTEM_DELAY':'WEATHER_DELAY']
df_f4['TOTAL_DELAY'] = df_f4.sum(axis=1)
df_f3['TOTAL_DELAY'] = df_f4.loc[:,'TOTAL_DELAY']
df_f5 = df_f3.loc[:,['MONTH','DAY','DAY_OF_WEEK','SCHEDULED_DEPARTURE','SCHEDULED_ARRIVAL','AIR_SYSTEM_DELAY','SECURITY_DELAY','AIRLINE_DELAY','LATE_AIRCRAFT_DELAY','TOTAL_DELAY']]
df_f5

X = df_f5.loc[:, :'LATE_AIRCRAFT_DELAY']
y = df_f5.loc[:, 'TOTAL_DELAY']

# Generate the train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=1)

from sklearn.neighbors import KNeighborsRegressor

# define the model.  Neighborhood size = 15 (try changing the neighborhood size)
knn = KNeighborsRegressor(n_neighbors = 15, weights = 'uniform')

# "Train" the model
knn.fit(X_train, y_train)

# Run the model
y_pred = knn.predict(X_test)

print('R squared: ', knn.score(X_test, y_test))

"""# K-Means"""

df_kcl = df_f5[['MONTH','DAY','TOTAL_DELAY']]
df_kcl['DAY'] = df_kcl['DAY'].apply(lambda x: '{0:0>2}'.format(x))
df_kcl['MONTH']=df_kcl['MONTH'].astype(str)
df_kcl['DAY']=df_kcl['DAY'].astype(str)
df_kcl['MMDD'] = df_kcl[['MONTH', 'DAY']].apply(lambda x: ''.join(x), axis=1)
df_kcl

df_kcl['MMDD']=df_kcl['MMDD'].astype(int)
df_kcl

from sklearn.cluster import KMeans

X = df_kcl.loc[:, ['MMDD','TOTAL_DELAY']].values

wcss = []
for k in range(5,21): 
     kmeans = KMeans(n_clusters = k, random_state = 0, n_init=10)
     kmeans.fit(X)
     wcss.append(kmeans.inertia_)
wcss

import matplotlib.pyplot as plt

plt.rcParams["figure.figsize"] = (7,7)
plt.plot(range(5,21), wcss, linewidth = 3)
plt.title('The Elbow Method Graph')
plt.xlabel('Number of clusters')
plt.ylabel('WCSS (Error)')
plt.show()

kmeans = KMeans(n_clusters=10, init ='k-means++', random_state=0, n_init=10)
y_kmeans = kmeans.fit_predict(X)

plt.scatter(X[:, 0], X[:, 1], c = y_kmeans, s = 100)

# Plot the centroids
plt.rcParams["figure.figsize"] = (10,10)

plt.scatter(kmeans.cluster_centers_[:, 0], 
            kmeans.cluster_centers_[:, 1], 
            marker = '*', 
            s = 500, 
            c = 'black')

plt.title('Clusters of Delays')
plt.xlabel('Day')
plt.ylabel('Delay in Minutes')
plt.show()

"""# Other

K-Means clustering
"""

from sklearn.cluster import KMeans

X = df_f5.loc[:, ['SCHEDULED_DEPARTURE','TOTAL_DELAY']].values

wcss = []
for k in range(5,21): 
     kmeans = KMeans(n_clusters = k, random_state = 0, n_init=10)
     kmeans.fit(X)
     wcss.append(kmeans.inertia_)
wcss

import matplotlib.pyplot as plt

plt.rcParams["figure.figsize"] = (7,7)
plt.plot(range(5,21), wcss, linewidth = 3)
plt.title('The Elbow Method Graph')
plt.xlabel('Number of clusters')
plt.ylabel('WCSS (Error)')
plt.show()

kmeans = KMeans(n_clusters=10, init ='k-means++', random_state=0, n_init=10)
y_kmeans = kmeans.fit_predict(X)

plt.scatter(X[:, 0], X[:, 1], c = y_kmeans, s = 100)

# Plot the centroids
plt.rcParams["figure.figsize"] = (10,10)

plt.scatter(kmeans.cluster_centers_[:, 0], 
            kmeans.cluster_centers_[:, 1], 
            marker = '*', 
            s = 500, 
            c = 'black')

plt.title('Clusters of Delay Time')
plt.xlabel('Time of Day')
plt.ylabel('Delay in Minutes')
plt.show()